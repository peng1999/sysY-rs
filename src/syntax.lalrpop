use std::str::FromStr;

use crate::ast;

grammar;

pub Stmt: ast::Stmt = {
    <Expr> ";" => ast::Stmt::Expr(<>),
    <l:Expr> "=" <r:Expr> ";" => ast::Stmt::Assign(Box::new(l), Box::new(r)),
    "{" <StmtList> "}" => ast::Stmt::Block(<>),
    "{" "}" => ast::Stmt::Block(vec![]),
}

StmtList: Vec<ast::Stmt> = {
    Stmt                        => vec![<>],
    <mut l:StmtList> <s:Stmt>   => { l.push(s); l },
}

pub Expr: ast::Expr = AddExpr;

AddExpr = {
    MulExpr,
    <l:AddExpr> <op:AddOp> <r:MulExpr> => ast::Expr::Binary(op, Box::new(l), Box::new(r)),
}

MulExpr = {
    UnaryExpr,
    <l:MulExpr> <op:MulOp> <r:UnaryExpr> => ast::Expr::Binary(op, Box::new(l), Box::new(r)),
}

UnaryExpr = {
    <op:UnaryOp> <e:UnaryExpr>          => ast::Expr::Unary(op, Box::new(e)),
    <name:Ident> "(" <p:ParamList> ")"  => ast::Expr::Call(Box::new(name), p),
    <name:Ident> "(" ")"                => ast::Expr::Call(Box::new(name), vec![]),
    <name:Ident> <p:IndexList>          => ast::Expr::Call(Box::new(name), p),
    Scalar,
}

ParamList: Vec<ast::Expr> = {
    Expr => vec![<>],
    <mut p:ParamList> "," <e:Expr> => { p.push(e); p },
}

IndexList: Vec<ast::Expr> = {
    "[" <Expr> "]"                      => vec![<>],
    <mut p:IndexList> "[" <e:Expr> "]"  => { p.push(e); p },
}

Scalar = {
    NumLit,
    Ident,
    "(" <e:Expr> ")" => e,
}

//
// Tokens
//

NumLit: ast::Expr = r"[0-9]+" => ast::Expr::Lit(i32::from_str(<>).unwrap());
Ident: ast::Expr = r"[a-zA-Z][a-zA-Z0-9]*" => ast::Expr::Ident(<>.to_owned());

UnaryOp: ast::UnOp = {
    "+" => ast::UnOp::Pos,
    "-" => ast::UnOp::Neg,
    "!" => ast::UnOp::Not,
}

MulOp: ast::BinOp = {
    "*" => ast::BinOp::Mul,
    "/" => ast::BinOp::Div,
    "%" => ast::BinOp::Rem,
}

AddOp: ast::BinOp = {
    "+" => ast::BinOp::Add,
    "-" => ast::BinOp::Sub,
}
