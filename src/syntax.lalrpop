use std::str::FromStr;

use crate::ast;
use crate::context::{self, Context};

grammar(ctx: &mut Context<'input>);

match {
    "(", ")", "{", "}", "[", "]", ";", ",",
    "==", "!=", "<", ">", "<=", ">=", "=",
    "+", "-", "*", "/", "!", "%",
    "if", "else", "while", "return", "true", "false", "break", "continue",
    r"[a-zA-Z][a-zA-Z0-9]*",
    r"[0-9]+",
    r"\s*" => { }, // 忽略空白
    r"//[^\n\r]*[\n\r]*" => { }, // 双斜线注释
}

pub Prog = <Item*>;

Item: ast::Item = {
    <f:FuncHead> "{" <b:Stmt*> "}" => ast::Item::FuncDef(f, b),
    <FuncHead> ";" => ast::Item::FuncDecl(<>),
}

FuncHead: ast::FuncHead = {
    <r:Ident> <n:Ident> "(" <mut v:(<TypedName> ",")*> <e:TypedName?> ")" => {
        let void = ctx.interner.get_or_intern_static("void");
        let r = ctx.interner.get_or_intern(r);
        let n = ctx.interner.get_or_intern(n);
        let r_ty = (r != void).then(|| ctx.get_ty(r));
        if let Some(e) = e {
            v.push(e);
        }
        ast::FuncHead {
            name: n,
            ret_ty: r_ty,
            param: v,
        }
    }
}

TypedName: (ast::Ty, context::IString) = {
    <t:Ident> <n:Ident> => {
        let sym_t = ctx.interner.get_or_intern(t);
        let sym_n = ctx.interner.get_or_intern(n);
        let ty = ctx.get_ty(sym_t);
        (ty, sym_n)
    }
}

Stmt: ast::Stmt = {
    StmtOther,
    "if" "(" <c:Expr> ")" <t:Stmt> => ast::Stmt::If(c, Box::new(t), Box::new(ast::Stmt::Empty)),
    "if" "(" <c:Expr> ")" <t:WithElse> "else" <f:Stmt> => ast::Stmt::If(c, Box::new(t), Box::new(f)),
    "while" "(" <c:Expr> ")" <t:Stmt> => ast::Stmt::While(c, Box::new(t)),
}

WithElse = {
    StmtOther,
    "if" "(" <c:Expr> ")" <t:WithElse> "else" <f:WithElse> => ast::Stmt::If(c, Box::new(t), Box::new(f)),
    "while" "(" <c:Expr> ")" <t:WithElse> => ast::Stmt::While(c, Box::new(t)),
}

StmtOther: ast::Stmt = {
    Decl,
    <Expr> ";" => ast::Stmt::Expr(<>),
    <Expr> "=" <Expr> ";" => ast::Stmt::Assign(<>),
    "{" <Stmt*> "}" => ast::Stmt::Block(<>),
    ";" => ast::Stmt::Empty,
    "return" <Expr?> ";" => ast::Stmt::Return(<>),
}

Decl: ast::Stmt = {
    <tn:TypedName> "=" <v:Expr> ";" => {
        let (ty, sym_n) = tn;
        ast::Stmt::Decl(ty, sym_n, v)
    },
}

Expr: ast::Expr = CmpExpr;

CmpExpr = {
    AddExpr,
    Spanned<CmpExprKind>,
}
CmpExprKind: ast::ExprKind =
    <l:CmpExpr> <op:CmpOp> <r:AddExpr> => ast::ExprKind::Binary(op, l, r);

AddExpr = {
    MulExpr,
    Spanned<AddExprKind>,
}
AddExprKind: ast::ExprKind =
    <l:AddExpr> <op:AddOp> <r:MulExpr> => ast::ExprKind::Binary(op, l, r);

MulExpr = {
    UnaryExpr,
    Spanned<MulExprKind>,
}
MulExprKind: ast::ExprKind =
    <l:MulExpr> <op:MulOp> <r:UnaryExpr> => ast::ExprKind::Binary(op, l, r);

UnaryExpr = {
    Spanned<UnaryExprKind>,
    Scalar,
}
UnaryExprKind: ast::ExprKind = {
    <op:UnaryOp> <e:UnaryExpr>              => ast::ExprKind::Unary(op, e),
    <name:IdentExpr> "(" <p:ParamList> ")"  => ast::ExprKind::Call(name, p),
    <name:IdentExpr> "(" ")"                => ast::ExprKind::Call(name, vec![]),
    <name:IdentExpr> <p:IndexList>          => ast::ExprKind::Index(name, p),
}

ParamList: Vec<ast::Expr> = {
    Expr => vec![<>],
    <mut p:ParamList> "," <e:Expr> => { p.push(e); p },
}

IndexList: Vec<ast::Expr> = {
    "[" <Expr> "]"                      => vec![<>],
    <mut p:IndexList> "[" <e:Expr> "]"  => { p.push(e); p },
}

Scalar = {
    Spanned<BoolLit>,
    Spanned<NumLit>,
    IdentExpr,
    "(" <e:Expr> ")" => e,
}

IdentExpr: ast::Expr = Spanned<IdentKind>;
IdentKind: ast::ExprKind = <s:Ident> => ast::ExprKind::Ident(ctx.interner.get_or_intern(s));

Spanned<T>: ast::Expr = {
    <l:@L> <v:T> <r:@R> => ast::Spanned::new((l, r), v),
}

//
// Tokens
//

BoolLit: ast::ExprKind = {
    "true" => ast::ExprKind::BoolLit(true),
    "false" => ast::ExprKind::BoolLit(false),
}
NumLit: ast::ExprKind = r"[0-9]+" => ast::ExprKind::IntLit(i32::from_str(<>).unwrap());
Ident = r"[a-zA-Z][a-zA-Z0-9]*";

UnaryOp: ast::UnOp = {
    "+" => ast::UnOp::Pos,
    "-" => ast::UnOp::Neg,
    "!" => ast::UnOp::Not,
}

MulOp: ast::BinOp = {
    "*" => ast::BinOp::Mul,
    "/" => ast::BinOp::Div,
    "%" => ast::BinOp::Rem,
}

AddOp: ast::BinOp = {
    "+" => ast::BinOp::Add,
    "-" => ast::BinOp::Sub,
}

CmpOp: ast::BinOp = {
   "==" => ast::BinOp::Eq,
   "!=" => ast::BinOp::Ne,
   "<"  => ast::BinOp::Lt,
   "<=" => ast::BinOp::Le,
   ">"  => ast::BinOp::Gt,
   ">=" => ast::BinOp::Ge,
}
