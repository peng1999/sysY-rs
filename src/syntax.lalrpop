use std::str::FromStr;

use crate::ast;
use crate::context::Context;

grammar(ctx: &mut Context);

pub Item: ast::Item = {
    <r:Ident> <n:Ident> "(" ")" "{" <b:Stmt*> "}" => {
        let r = ctx.interner.get_or_intern(r);
        let n = ctx.interner.get_or_intern(n);
        ast::Item::FuncDef(r, n, vec![], b)
    }
}

Stmt: ast::Stmt = {
    StmtOther,
    "if" "(" <c:Expr> ")" <t:Stmt> => ast::Stmt::If(Box::new(c), Box::new(t), Box::new(ast::Stmt::Empty)),
    "if" "(" <c:Expr> ")" <t:WithElse> "else" <f:Stmt> => ast::Stmt::If(Box::new(c), Box::new(t), Box::new(f)),
}

WithElse = {
    StmtOther,
    "if" "(" <c:Expr> ")" <t:WithElse> "else" <f:WithElse> => ast::Stmt::If(Box::new(c), Box::new(t), Box::new(f)),
}

StmtOther: ast::Stmt = {
    Decl,
    <Expr> ";" => ast::Stmt::Expr(<>),
    <l:Expr> "=" <r:Expr> ";" => ast::Stmt::Assign(Box::new(l), Box::new(r)),
    "{" <Stmt*> "}" => ast::Stmt::Block(<>),
    ";" => ast::Stmt::Empty,
    "return" <v:Expr?> ";" => ast::Stmt::Return(v),
}

Decl: ast::Stmt = {
    <t:Ident> <n:Ident> "=" <v:Expr> ";" => {
        let sym_t = ctx.interner.get_or_intern(t);
        let sym_n = ctx.interner.get_or_intern(n);
        ast::Stmt::Decl(sym_t, sym_n, Box::new(v))
    },
}

Expr: ast::Expr = AddExpr;

AddExpr = {
    MulExpr,
    <l:AddExpr> <op:AddOp> <r:MulExpr> => ast::Expr::Binary(op, Box::new(l), Box::new(r)),
}

MulExpr = {
    UnaryExpr,
    <l:MulExpr> <op:MulOp> <r:UnaryExpr> => ast::Expr::Binary(op, Box::new(l), Box::new(r)),
}

UnaryExpr = {
    <op:UnaryOp> <e:UnaryExpr>              => ast::Expr::Unary(op, Box::new(e)),
    <name:IdentExpr> "(" <p:ParamList> ")"  => ast::Expr::Call(Box::new(name), p),
    <name:IdentExpr> "(" ")"                => ast::Expr::Call(Box::new(name), vec![]),
    <name:IdentExpr> <p:IndexList>          => ast::Expr::Index(Box::new(name), p),
    Scalar,
}

ParamList: Vec<ast::Expr> = {
    Expr => vec![<>],
    <mut p:ParamList> "," <e:Expr> => { p.push(e); p },
}

IndexList: Vec<ast::Expr> = {
    "[" <Expr> "]"                      => vec![<>],
    <mut p:IndexList> "[" <e:Expr> "]"  => { p.push(e); p },
}

Scalar = {
    BoolLit,
    NumLit,
    IdentExpr,
    "(" <e:Expr> ")" => e,
}

IdentExpr: ast::Expr = Ident => ast::Expr::Ident(ctx.interner.get_or_intern(<>));

//
// Tokens
//

BoolLit: ast::Expr = {
    "true" => ast::Expr::BoolLit(true),
    "false" => ast::Expr::BoolLit(false),
}
NumLit: ast::Expr = r"[0-9]+" => ast::Expr::IntLit(i32::from_str(<>).unwrap());
Ident = r"[a-zA-Z][a-zA-Z0-9]*";

UnaryOp: ast::UnOp = {
    "+" => ast::UnOp::Pos,
    "-" => ast::UnOp::Neg,
    "!" => ast::UnOp::Not,
}

MulOp: ast::BinOp = {
    "*" => ast::BinOp::Mul,
    "/" => ast::BinOp::Div,
    "%" => ast::BinOp::Rem,
}

AddOp: ast::BinOp = {
    "+" => ast::BinOp::Add,
    "-" => ast::BinOp::Sub,
}
